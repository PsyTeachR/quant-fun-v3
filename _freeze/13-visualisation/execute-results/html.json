{
  "hash": "9bc0602d96322a83d4667397f0b3c543",
  "result": {
    "markdown": "# Visualisation\n\n\n\n\n\nIn this chapter we are going to focus on visualising data using `ggplot2`. You've already created a number of different plots including bar charts, scatterplots, histograms, qq-plots, and violin-boxplots, but now we will show you how to customise your plots further to give you a better idea of the range and flexibility of visualising data in R. \n\nIn this chapter, you won't be asked to write any code yourself, we will give you all the example code. Instead, play with the arguments, change TRUE to FALSE and vice-versa, change the values and colours. This will help you learn what each bit does. \n\nFor all of the activities in this chapter we are going to use data from  Experiment 3 of [Zhang, T., Kim, T., Brooks, A. W., Gino, F., & Norton, M. I. (2014). A \"present\" for the future: The unexpected value of rediscovery. Psychological Science, 25, 1851-1860.](https://journals.sagepub.com/doi/abs/10.1177/0956797614542274).\n\nTo help you understand the data we're visualising, here is the abstract:\n\n> Although documenting everyday activities may seem trivial, four studies reveal that creating records of the present generates unexpected benefits by allowing future rediscoveries. In Study 1, we used a time-capsule paradigm to show that individuals underestimate the extent to which rediscovering experiences from the past will be curiosity provoking and interesting in the future. In Studies 2 and 3, we found that people are particularly likely to underestimate the pleasure of rediscovering ordinary, mundane experiences, as opposed to extraordinary experiences. Finally, Study 4 demonstrates that underestimating the pleasure of rediscovery leads to time-inconsistent choices: Individuals forgo opportunities to document the present but then prefer rediscovering those moments in the future to engaging in an alternative fun activity. Underestimating the value of rediscovery is linked to peopleâ€™s erroneous faith in their memory of everyday events. By documenting the present, people provide themselves with the opportunity to rediscover mundane moments that may otherwise have been forgotten.\n\n## Activity 1: Set-up Visualisation {#viz-a1}\n\n* Open R Studio and set the working directory to your chapter folder. Ensure the environment is clear.   \n* Open a new R Markdown document and save it in your working directory. Call the file \"Visualisation\".    \n* Download <a href=\"Zhang et al. 2014 Study 3.csv\" download>Zhang et al. 2014 Study 3.csv</a> and save it in your chapter folder. Make sure that you do not change the file name at all.\n* If you're on the server, avoid a number of issues by restarting the session - click `Session` - `Restart R` \n* Delete the default R Markdown welcome text and insert a new code chunk that loads the package `tidyverse` using the `library()` function. \n* Run the below code to load and wrangle the data into tidy data.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nzhang_data <- read_csv(\"Zhang et al. 2014 Study 3.csv\")%>%\n  select(Gender, Age,Condition, T1_Predicted_Interest_Composite, T2_Actual_Interest_Composite)%>%\n  mutate(subject = row_number())%>%\n  pivot_longer(names_to = \"time\",values_to = \"interest\",\n               cols = T1_Predicted_Interest_Composite:T2_Actual_Interest_Composite)%>%\n  mutate(Condition = recode(Condition, \"1\" = \"Ordinary\", \"2\" = \"Extraordinary\"))%>%\n  mutate(time = recode(time, \"T1_Predicted_Interest_Composite\" = \"time1_interest\", \"T2_Actual_Interest_Composite\" = \"time2_interest\"),\n         Gender = recode(Gender, \"1\" = \"male\", \"2\" = \"female\")) %>%\n  filter(Gender %in% c(\"male\", \"female\"))\n```\n:::\n\n\n## Activity 2: Histograms {#viz-a2}\n\nFirst, let's create histograms for `interest` to check the distribution. \nThe first line of code creates the `ggplot()` object and specifies which dataset is being used, and what should be represented on the x and y-axis. Because this is a histogram, you only need to specify the variable on the x-axis because y is always frequency\n\n### Basic histogram\n\nThe code below will create a simple histogram with default appearance and no customisation. You wouldn't use this graph in a paper, but if you just want to quickly check your distributions, for e.g., normality, this code might be enough. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(zhang_data, aes(interest))+ \n  geom_histogram()\n```\n\n::: {.cell-output-display}\n![Basic histogram](13-visualisation_files/figure-html/hist1-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n### Colour and fill\n\nThe next section of code will change the appearance. Plots in ggplot2 are highly customisable - [R for Data Science](https://r4ds.had.co.nz/data-visualisation.html) has an excellent chapter on `ggplot` if you would like additional information. \n\nAdding `binwidth` to `geom_histogram()` changes the bins of the histogram, i.e., how wide the bars are. The default is 30. Sometimes this may be appropriate but often you will want to change the binwidth. What value you give will depend upon your data.\n\n`colour()` changes the colour of the line around the bars. `fill()` changes the fill of the bars. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(zhang_data, aes(x = interest))+ \n  geom_histogram(binwidth = .3, \n                 colour = \"black\",  \n                 fill = \"grey\") \n```\n\n::: {.cell-output-display}\n![Histogram with colour changes](13-visualisation_files/figure-html/hist2-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n### Axis labels\n\nThe next section of code changes the labels on the graphs. Note that the labels are an additional layer (i.e., it comes after an `+`, rather than being an argument to `geom_histogram()`).\n\nThe function you use will depend on your data, the most common are `scale_x/y_continuous` and `scale_x/y_discrete` depending on whether you are displaying continuous or categorical data. Again, each axis is a separate layer. \n\nThese scale functions control all the information about the axis, from the label to the breaks, to the minimum and maximum values. For more information use the help documentation. \n\nFor our labelling purposes, there are two main arguments:\n\n1. `name()` controls the main name of the axis\n2. `labels()` controls the name of the breaks  \n\nFor our histogram we will just change the main axis labels. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(zhang_data, aes(x = interest))+ \n  geom_histogram(binwidth = .3, \n                 colour = \"black\",  \n                 fill = \"grey\") + \n  scale_x_continuous(name = \"Mean interest score (1-7)\") +\n  scale_y_continuous(name = \"Count\") \n```\n\n::: {.cell-output-display}\n![Histogram with label changes](13-visualisation_files/figure-html/hist3-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n### Density curve\n\nThe following section adds a normal density curve to the histogram, which can be useful for checking the assumption of normality.\n\nTo add the line you must change the `geom_histogram()` to use density on the y-axis (the default is count) and add a `stat_function()` layer that draws the line.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(zhang_data, aes(interest))+ \n  geom_histogram(binwidth = .3, \n                 colour = \"black\", \n                 fill = \"grey\",\n                 aes(y = ..density..))+ # change y-axis to density\n  scale_x_continuous(name = \"Mean interest score (1-7)\") +\n  scale_y_continuous(name = \"Count\") +\n  stat_function(fun = dnorm, # this adds a normal density function curve\n                colour = \"red\", # this makes it red\n                args = list(mean = mean(zhang_data$interest, na.rm = TRUE),\n                           sd = sd(zhang_data$interest, na.rm = TRUE)))\n```\n\n::: {.cell-output-display}\n![Histogram with normal density curve](13-visualisation_files/figure-html/hist4-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n## Activity 3: Scatterplots {#viz-a3}\n\n### Basic scatterplot\n\nNow let's make a scatterplot plotting `Age` and `interest` to see if there is any relationship between the two. We need to specify both the x and y-axis variables. The following code will produce a very simple scatterplot. Again, you wouldn't use this graph in a paper, but for eye-balling your data it would suffice. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(zhang_data, aes(x = interest,y = Age))+\n       geom_point()\n```\n\n::: {.cell-output-display}\n![Basic scatterplot](13-visualisation_files/figure-html/scat1-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n### Axis labels\n\nFrom this plot it doesn't look like there is much of a relationship between age and interest ratings. We can now change the labels using the same scale functions as before. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(zhang_data, aes(x = interest,y = Age))+\n       geom_point()+\n  scale_x_continuous(name = \"Mean interest score (1-7)\") + \n  scale_y_continuous(name = \"Age\")\n```\n\n::: {.cell-output-display}\n![Scatterplot with label changes](13-visualisation_files/figure-html/scat2-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n### Adding a regression line\n\nIt's often useful to add a regression line or line of best fit to a scatterplot. The regression line is added with `geom_smooth()` and by default will also provide a 95% confidence interval. You can specify what type of line you want to draw, most often you will need `method = lm`, i.e., a linear model or a straight line. Look up the help documentation for `geom_smooth()` and see what other methods you can use. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(zhang_data, aes(x = interest,y = Age))+\n  geom_point()+\n  scale_x_continuous(name = \"Mean interest score (1-7)\") + \n  scale_y_continuous(name = \"Age\")+\n  geom_smooth(method=lm) # if you don't want the shaded CI, add se = FALSE to this\n```\n\n::: {.cell-output-display}\n![Scatterplot with regression line](13-visualisation_files/figure-html/scat3-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n### Grouped scatterplots\n\nWe can use ggplot to show how the relationship might differ for different populations within our data. We do this by adding `colour()` to `aes()` and setting it as whatever variable we would like to distinguish between. In this case, we will see how the relationship between age and interest differs for the male and female participants. There are a few participants with missing gender so we will first filter them out.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nzhang_data %>%\n  filter(Gender %in% c(\"male\", \"female\")) %>%\n           ggplot(aes(x = interest,y = Age, colour = Gender))+\n  geom_point()+\n  scale_x_continuous(name = \"Mean interest score (1-7)\") + \n  scale_y_continuous(name = \"Age\")+\n  geom_smooth(method=lm)\n```\n\n::: {.cell-output-display}\n![Grouped scatterplot](13-visualisation_files/figure-html/scat4-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\nAnd here's that plot with the labels tidied up. Notice the use of `scale_color_discrete()` to adjust the labels for Gender. \n\n\n::: {.cell layout-align=\"center\" type='warning'}\n<div class=\"warning\">\n<p>When you change the <code>labels</code>, R will simply overwrite the\nnames in the dataset. If you wanted to actually change the order of the\ncategories (e.g., have male as the red line) you need to change the\norder of the factor. We will do this later, for now, just be sure that\nyouâ€™re changing the name of the right category (i.e., female comes\nfirst))</p>\n</div>\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(zhang_data, aes(x = interest,y = Age, colour = Gender))+\n  geom_point()+\n  scale_x_continuous(name = \"Mean interest score (1-7)\") + \n  scale_y_continuous(name = \"Age\")+\n  geom_smooth(method=lm)+\n  scale_color_discrete(name = \"Gender\",\n                       labels = c(\"Female\", \"Male\"))\n```\n\n::: {.cell-output-display}\n![Grouped scatterplot with adjusted labels](13-visualisation_files/figure-html/scat5-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n## Activity 4: Boxplots {#viz-a4}\n\n### Basic boxplot\n\nThe following code will produce a simple boxplot for eye-balling your data.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(zhang_data, aes(x = Condition, y = interest))+\n  geom_boxplot()\n```\n\n::: {.cell-output-display}\n![Basic boxplot](13-visualisation_files/figure-html/bp1-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n### Adding data points\n\nIf we add another layer `geom_point()` we can add our raw data points to our boxplots to make them more informative.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(zhang_data, aes(x = Condition, y = interest))+\n  geom_boxplot()+\n  geom_point()\n```\n\n::: {.cell-output-display}\n![Boxplot with overplotting](13-visualisation_files/figure-html/bp2-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\nHowever, this plot suffers from **over-plotting**, that is, there are multiple data points on top of each other. We can change this by using `geom_jitter()`, which adds a layer of points that are jittered so that each one is visible.\n\n`height` and `width` affect how much each point is jittered. Play around with the values to see how it affects the data points. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(zhang_data, aes(x = Condition, y = interest))+\n  geom_boxplot()+\n  geom_jitter(height = 0, width = .1)\n```\n\n::: {.cell-output-display}\n![Boxplot with jittered data](13-visualisation_files/figure-html/bp3-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n### Adding colour\n\nWe may want to add colour to our graph (and for consistency, we'll sort out the labels). We do this by adding the 'fill' argument to the ggplot aesthetic by specifying which variable the colour of the fill should be organised by. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(zhang_data, aes(x = Condition, y = interest, fill = Condition))+\n  geom_boxplot()+\n  geom_jitter(height = 0, width = .1)+\n  scale_x_discrete(name = \"Condition\") + # note the x-axis is discrete\n  scale_y_continuous(name = \"Mean interest rating (1-7)\")+\n  scale_fill_discrete(guide = FALSE) # this suppresses the legend because we don't need it\n```\n\n::: {.cell-output-display}\n![Boxplot with colour](13-visualisation_files/figure-html/bp4-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n### Boxplots for multiple factors\n\nWhen you only have one IV, using the fill command to change the colour is a little redundant, as the colours don't add any additional information. It makes more sense to use colour to represent an additional IV. \n\nFor this example, we'll use `Condition` and `time` as IVs. `fill()` now specifies a second IV, rather than repeating the IV on the x-axis as in the previous plot. \n\nWith multiple IVs the command to overlay the raw data points changes as the data points also need dodged (try running the code with the previous geom_jitter function to see what happens)\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(zhang_data, aes(x = Condition, y = interest, fill = time))+\n  geom_boxplot()+\n  geom_point(position=position_jitterdodge(jitter.width = .1))\n```\n\n::: {.cell-output-display}\n![Boxplot for two factors](13-visualisation_files/figure-html/bp5-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n### Colour-blind friendly options\n\nThere is one more fill option that we can use. Rather than specifying `scale_fill_discrete()`, we can use `scale_fill_viridis_d()`. This function does exactly the same thing but it uses a colour-blind friendly palette (which also prints in black and white). There are 5 different options for colours and you can see them by changing `option` to A, B, C, D or E. Personally I like option E with `alpha = .6` (to control transparency) but that's not an official School position.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(zhang_data, aes(x = Condition, y = interest, fill = time))+\n  geom_boxplot(alpha = .6)+\n  geom_point(position=position_jitterdodge(jitter.width = .1)) +\n  scale_fill_viridis_d(option = \"E\")\n```\n\n::: {.cell-output-display}\n![Boxplots with friendly colours](13-visualisation_files/figure-html/unnamed-chunk-2-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n## Activity 5: Reordering factors {#viz-a5}\n\nR orders categorical variables alphabetically. For gender it didn't really matter whether male or female was represented first and for time 1 and 2 it makes sense for them to be in this order but we may want to change the order of Condition (in my mind it makes more sense for Ordinary to come first, but that may just be me).\n\nTo do this we can use `mutate()` and `fct_level()` to change the factor levels to the order we want.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nzhang_data <- zhang_data %>%\n  mutate(Condition = fct_relevel(Condition, c(\"Ordinary\", \"Extraordinary\")))\n```\n:::\n\n\nNow we can re-run the boxplot. That's better. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(zhang_data, aes(x = Condition, y = interest, fill = time))+\n  geom_boxplot(alpha = .6)+\n  geom_point(position=position_jitterdodge(jitter.width = .1)) +\n  scale_fill_viridis_d(option = \"E\")\n```\n\n::: {.cell-output-display}\n![Boxplot with reordered factors](13-visualisation_files/figure-html/bp6-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n## Activity 6: Bar Charts {#viz-a6}\n\n### Basic bar chart\n\nBar charts should only be used for counts because they can distort your understanding of the data if you use them to represent means (see [here for a great example](https://www.autodeskresearch.com/publications/samestats). \n\nFirst, we'll do a bar chart for the count of male and females in our sample.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(zhang_data, aes(x=Gender))+\n  geom_bar()\n```\n\n::: {.cell-output-display}\n![Basic bar chart](13-visualisation_files/figure-html/bc1-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n### Bar charts with two factors\n\nWe can also use `fill()` to separate gender by Condition\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(zhang_data, aes(x=Gender, fill = Condition))+\n  geom_bar(position = \"dodge\", alpha = .6) + # the position argument places the bars next to each other, rather than on top of each other, try removing this\n  scale_fill_viridis_d(option = \"E\")\n```\n\n::: {.cell-output-display}\n![Bar chart with two factors](13-visualisation_files/figure-html/bc2-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n## Activity 7: Violin plots {#viz-a7}\n\n### Basic violin plot\n\nViolin plots are so-called because with a normal distribution the shape would look something like a violin. They show density, i.e., the fatter the violin the more data points there are for that value.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(zhang_data, aes(x = Condition, y = interest))+\n  geom_violin()\n```\n\n::: {.cell-output-display}\n![Basic violin plot](13-visualisation_files/figure-html/vp1-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n### Violin plots with raw data points\n\nLike the boxplot, we can also add the raw data points to our violin plot, making sure to use jitter  to avoid over-plotting.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(zhang_data, aes(x = Condition, y = interest))+\n  geom_violin()+\n  geom_jitter(height = 0, width = .1)\n```\n\n::: {.cell-output-display}\n![Violin plot with data points](13-visualisation_files/figure-html/vp2-1.png){fig-align='center' width=100%}\n:::\n:::\n\n::: {.cell layout-align=\"center\" type='warning'}\n<div class=\"warning\">\n<p>Itâ€™s important to remember that R is very literal.\n<code>ggplot2</code> works on a system of layers. It will add new geoms\non top of existing ones and it wonâ€™t stop to think whether this is a\ngood idea. Try running the above code but put <code>geom_jitter()</code>\nfirst and then add <code>geom_violin()</code>. The order of your layers\nmatters.</p>\n</div>\n:::\n\n\n## Activity 8: Violin-boxplots {#viz-a8}\n\nOne increasingly common graph is a violin + boxplot + summary plot that shows a huge amount of information about your data in a single plot. \n\n* This code uses two calls to `stat_summary()` that was introduced during the t-test chapter. The first draws a `point` to represent the mean, and the second draws an `errorbar` that represents standard error (`mean_se`).  \n* `guides` is a new function and can be used to adjust whether legends are displayed. This has the same effect as specifying `show.legend = FALSE` in both `geom_violin()` and `geom_boxplot()` but it uses less code to do so.  \n* `fatten = NULL` removes the median line from the boxplots. This can be useful if you're running a test where you're comparing means as it makes it easier to see the point range. \n* You may get warning messages telling you that R has removed rows containing missing values, you do not need to worry about this.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(zhang_data, aes(x = Condition, y = interest, fill = Condition))+\n  geom_violin(alpha = .6, trim = FALSE)+\n  geom_boxplot(width = .2, alpha = .7, fatten = NULL)+\n  stat_summary(fun = \"mean\", geom = \"point\") +\n  stat_summary(fun.data = \"mean_se\", geom = \"errorbar\", width = .1) +\n  scale_fill_viridis_d(option = \"E\", label = c(\"Ordinary\", \"Extraordinary\"))+\n  scale_y_continuous(name = \"Mean interest rating (1-7)\") +\n  guides(fill = FALSE)\n```\n\n::: {.cell-output-display}\n![Violin-boxplot with summary data](13-visualisation_files/figure-html/vbp1-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n## Activity 9: Faceting {#viz-a9}\n\n`ggplot2` contains a facet function that produces different plots for each level of a grouping variable which can be very useful when you have more than two factors, for example, for a three-way ANOVA. The following code displays produces violin-boxplots for Condition ~ interest, but separately for male and female participants. \n\n* This code adds an extra argument `position = position_dodge(.9)` to align the layers with the violin plots. Try removing this argument from each layer to see what happens, and also try adjusting the value from `.9` to another number.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(zhang_data, aes(x = Condition, y = interest, fill = time))+\n  geom_violin(alpha = .6, trim = FALSE)+\n  geom_boxplot(width = .2, \n               alpha = .6, \n               fatten = NULL,\n               position = position_dodge(.9))+\n  stat_summary(fun = \"mean\", geom = \"point\",\n               position = position_dodge(.9)) +\n  stat_summary(fun.data = \"mean_se\", geom = \"errorbar\", width = .1,\n               position = position_dodge(.9))+\n  scale_fill_viridis_d(option = \"E\") +\n  facet_wrap(~Gender)\n```\n\n::: {.cell-output-display}\n![Violin-boxplot facetted by gender](13-visualisation_files/figure-html/facet1-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n### Facet labelling\n\nFinally, changing the labels within the facets is a little more complicated - there's no additional scale layer, instead, you adjust this inside `facet_wrap()` using `labeller`. This has always felt unintuitive to me and I have to look it up every single time so don't worry if it is confusing - just remember where to look for the example. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(zhang_data, aes(x = Condition, y = interest, fill = time))+\n  geom_violin(alpha = .6, trim = FALSE)+\n  geom_boxplot(width = .2, \n               alpha = .6, \n               fatten = NULL,\n               position = position_dodge(.9))+\n  stat_summary(fun = \"mean\", geom = \"point\",\n               position = position_dodge(.9)) +\n  stat_summary(fun.data = \"mean_se\", geom = \"errorbar\", width = .1,\n               position = position_dodge(.9))+\n  scale_fill_viridis_d(option = \"E\") +\n  facet_wrap(~Gender, labeller = labeller(Gender = (c(female = \"Female\", male = \"Male\"))))\n```\n\n::: {.cell-output-display}\n![Facetted plot with updated labels](13-visualisation_files/figure-html/facet2-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n## Activity 10: Split-violins and raincloud plots {#viz-a10}\n\nFinally, we're going to do something a bit snazzy. As well as the functions that are included in packages, anyone can also write custom functions and share the code. One such custom function allows us to create **raincloud plots** which are highly informative and very pretty. See [here](https://wellcomeopenresearch.org/articles/4-63) for more information about their creation and function (and to cite them if you use them in a publication or report).\n\nIn order to use this custom function code you will need to install the `plyr` package, although crucially, don't load it like you normally would using `library()`. The custom function code will just use one very specific function, if you load the entire package you risk creating a function conflict.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ninstall.packages(\"plyr\")\n```\n:::\n\n\n\n### Split-violin plots\n\nBecause the functions we need don't exist in a package we can load, we need to create them. Copy and paste all  the below code without changing anything. You do not need to understand this code. I certainly don't. When you run this, you should see `geom_split_violin` appear in the Environment pane under Functions. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nGeomSplitViolin <- ggproto(\n  \"GeomSplitViolin\", \n  GeomViolin, \n  draw_group = function(self, data, ..., draw_quantiles = NULL) {\n    data <- transform(data, \n                      xminv = x - violinwidth * (x - xmin), \n                      xmaxv = x + violinwidth * (xmax - x))\n    grp <- data[1,'group']\n    newdata <- plyr::arrange(\n      transform(data, x = if(grp%%2==1) xminv else xmaxv), \n      if(grp%%2==1) y else -y\n    )\n    newdata <- rbind(newdata[1, ], newdata, newdata[nrow(newdata), ], newdata[1, ])\n    newdata[c(1,nrow(newdata)-1,nrow(newdata)), 'x'] <- round(newdata[1, 'x']) \n    if (length(draw_quantiles) > 0 & !scales::zero_range(range(data$y))) {\n      stopifnot(all(draw_quantiles >= 0), all(draw_quantiles <= 1))\n      quantiles <- ggplot2:::create_quantile_segment_frame(data, draw_quantiles)\n      aesthetics <- data[rep(1, nrow(quantiles)), setdiff(names(data), c(\"x\", \"y\")), drop = FALSE]\n      aesthetics$alpha <- rep(1, nrow(quantiles))\n      both <- cbind(quantiles, aesthetics)\n      quantile_grob <- GeomPath$draw_panel(both, ...)\n      ggplot2:::ggname(\"geom_split_violin\", \n                       grid::grobTree(GeomPolygon$draw_panel(newdata, ...), quantile_grob))\n    } else {\n      ggplot2:::ggname(\"geom_split_violin\", GeomPolygon$draw_panel(newdata, ...))\n    }\n  }\n)\n\ngeom_split_violin <- function (mapping = NULL, \n                               data = NULL, \n                               stat = \"ydensity\", \n                               position = \"identity\", ..., \n                               draw_quantiles = NULL, \n                               trim = TRUE, \n                               scale = \"area\", \n                               na.rm = FALSE, \n                               show.legend = NA, \n                               inherit.aes = TRUE) {\n  layer(data = data, \n        mapping = mapping, \n        stat = stat, \n        geom = GeomSplitViolin, \n        position = position, \n        show.legend = show.legend, \n        inherit.aes = inherit.aes, \n        params = list(trim = trim, \n                      scale = scale, \n                      draw_quantiles = draw_quantiles, \n                      na.rm = na.rm, ...)\n  )\n}\n```\n:::\n\n\nThe split-violin is a version of the violin-boxplot that is good for visualising interactions. If you look at the faceted graph we made, there's actually quite a lot of unnecessary space used up because we only need half of the violin to see the distribution - the other half is just repeating the same information. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(zhang_data, aes(x = Condition, y = interest, fill = Gender))+\n  geom_split_violin(trim = FALSE, alpha = .4)+\n  geom_boxplot(width = .2, alpha = .6,\n               position = position_dodge(.25))+\n  scale_fill_viridis_d(option = \"E\") +\n  stat_summary(fun = \"mean\", geom = \"point\",\n               position = position_dodge(width = 0.25)) +\n  stat_summary(fun.data = \"mean_se\", geom = \"errorbar\", width = .1,\n               position = position_dodge(width = 0.25))\n```\n\n::: {.cell-output-display}\n![Split-violin plot](13-visualisation_files/figure-html/sv1-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n### Raincloud plots\n\nThe second custom function is `geom_flat_violin`. Copy and paste all of this code and again you should see it appear in your Environment pane. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n\"%||%\" <- function(a, b) {\n  if (!is.null(a)) a else b\n}\n\ngeom_flat_violin <- function(mapping = NULL, data = NULL, stat = \"ydensity\",\n                             position = \"dodge\", trim = TRUE, scale = \"area\",\n                             show.legend = NA, inherit.aes = TRUE, ...) {\n  layer(\n    data = data,\n    mapping = mapping,\n    stat = stat,\n    geom = GeomFlatViolin,\n    position = position,\n    show.legend = show.legend,\n    inherit.aes = inherit.aes,\n    params = list(\n      trim = trim,\n      scale = scale,\n      ...\n    )\n  )\n}\n\nGeomFlatViolin <-\n  ggproto(\"Violinist\", Geom,\n          setup_data = function(data, params) {\n            data$width <- data$width %||%\n              params$width %||% (resolution(data$x, FALSE) * 0.9)\n            \n            # ymin, ymax, xmin, and xmax define the bounding rectangle for each group\n            data %>%\n              group_by(group) %>%\n              mutate(ymin = min(y),\n                     ymax = max(y),\n                     xmin = x,\n                     xmax = x + width / 2)\n            \n          },\n          \n          draw_group = function(data, panel_scales, coord) {\n            # Find the points for the line to go all the way around\n            data <- transform(data, xminv = x,\n                              xmaxv = x + violinwidth * (xmax - x))\n            \n            # Make sure it's sorted properly to draw the outline\n            newdata <- rbind(plyr::arrange(transform(data, x = xminv), y),\n                             plyr::arrange(transform(data, x = xmaxv), -y))\n            \n            # Close the polygon: set first and last point the same\n            # Needed for coord_polar and such\n            newdata <- rbind(newdata, newdata[1,])\n            \n            ggplot2:::ggname(\"geom_flat_violin\", GeomPolygon$draw_panel(newdata, panel_scales, coord))\n          },\n          \n          draw_key = draw_key_polygon,\n          \n          default_aes = aes(weight = 1, colour = \"grey20\", fill = \"white\", size = 0.5,\n                            alpha = NA, linetype = \"solid\"),\n          \n          required_aes = c(\"x\", \"y\")\n  )\n```\n:::\n\n\nThis plot is similar to the split-violin, but it adds in the raw data points and looks a bit like a raincloud as a result. \n  \nFirst, we will run the plot for just one variable, Condition. Again, try changing the arguments (adjust any numbers and change FALSE to TRUE) to see how you can control different aspects of the plot, in particular, try removing `coord_flip()` to see what happens.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(zhang_data, aes(x = Condition, y = interest))+\n  geom_flat_violin(position = position_nudge(x = .25, y = 0), \n                   trim=FALSE, alpha = 0.75) +\n  geom_jitter(aes(color = Condition), \n             width = .2, size = .5, alpha = .75, show.legend = FALSE)+\n  geom_boxplot(width = .1, alpha = 0.5, fatten = NULL)+\n  stat_summary(fun = \"mean\", geom = \"point\",\n               position = position_dodge(width = 0.25)) +\n  stat_summary(fun.data = \"mean_se\", geom = \"errorbar\", width = .1,\n               position = position_dodge(width = 0.3)) +\n  coord_flip()\n```\n\n::: {.cell-output-display}\n![Raincloud plot for one factor](13-visualisation_files/figure-html/rc1-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n### Raincloud plots with multiple factors\n\nNow we can run the code for a 2 x 2 plot, adding in Gender to `fill` argument. This is quite a complicated plot, do not worry if you are struggling to understand the code but remember, you just need to understand which bits to change. \n  \n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(zhang_data, \n       aes(x = Condition, y = interest, fill = Gender))+\n  geom_flat_violin(position = position_nudge(x = .25, y = 0), \n                   trim=FALSE, \n                   alpha = 0.6) +\n  geom_point(position = position_jitter(width = .05, height = 0.05), \n             size = .5, \n             alpha = .7, \n             show.legend = FALSE, \n             aes(colour = Gender))+\n  geom_boxplot(width = .3, \n               alpha = 0.5, \n               position = \"dodge\")+\n  stat_summary(fun = \"mean\", geom = \"point\",\n               position = position_dodge(width = 0.3)) +\n  stat_summary(fun.data = \"mean_se\", geom = \"errorbar\", width = .1,\n               position = position_dodge(width = 0.3)) +\n  scale_fill_viridis_d(option = \"E\") +\n  scale_colour_viridis_d(option = \"E\")\n```\n\n::: {.cell-output-display}\n![Raincloud plot for two factors](13-visualisation_files/figure-html/rc2-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n### Finished! {#viz-fin}\n\nAnd you're done! As we've said throughout this chapter, you do not need to remember all of this code, you just need to remember what's possible and where to find the examples that you can modify. \n\n",
    "supporting": [
      "13-visualisation_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}